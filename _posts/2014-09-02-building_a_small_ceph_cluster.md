---
layout: post
title: "组建小型Ceph集群 Building a Small Ceph Cluster"
categories: 文件系统
tags: [linux, ceph, cluster, dfs]
date: 2014-09-02 08:55:00
---

<pre>
本文转载自：http://www.fxzc.net/archives/zujianxiaoxingcephjiqun.html

英文原文地址：http://soft.aidns.cn/NAS/Ceph/Building a Small Ceph Cluster.htm
</pre>

简介
<pre>
我创建这份文档是基于我组建一个Ceph的分布式文件系统的小测试集群的经验。我用VMWare服务器安装，因为我发现它能快速，简单地达到我的目标，并且我身边没有任何可用的备用机。此外，VMware Server免费没有坏处也是事实！它主要用作我很容易忘记这样的事情的个人笔记。
机器安装和配置，
我的简单集群共有3个节点，所以我需要创建3个虚拟机。如果你之前从来没有使用VMware，这里是一个使用CentOS发行版创建Linux虚拟机简单的指南。如果您知道如何创建Linux虚拟机那就创建他们三个。此外，创建另一个虚拟机硬盘。这将是用于BTRFS文件系统。这可能是比较小。就我而言，我创建它为1 GB。
</pre>
当我们的3 个Linux节点启动和运行之后，我想修改/etc /hosts文件，这样我不必记住所有IP地址。我的/ etc / hosts文件看起来如下。
<pre>
# 不要删除以下行，或各种方案
# 否则需要的网络功能将失败。
127.0.0.1  localhost.localdomain
::1  localhost6.localdomain6 localhost6
192.168.221.137 ceph0
192.168.221.138 ceph1
192.168.221.139 ceph2
</pre>

导出Ceph的源代码

现在我们准备导出Ceph。当我们准备好时，我们将在稍后阶段创建它。如果Git你的机器不是存在，您可以按照这些指示进行安装。

{% highlight bash %}
# cd  /usr/src
# git clone git://ceph.newdream.net /ceph.git

Initialized empty Git repository in /usr/src/ceph/.git/
remote: Generating pack…
remote: Counting objects: 498
remote: Done counting 37941 objects.
remote: Deltifying 37941 objects…
remote:  100% (37941/37941) done
remote: Total 37941 (delta 30117), reused 34536 (delta 27139)
Receiving objects: 100% (37941/37941), 8.46 MiB | 568 KiB/s, done.
Resolving deltas: 100% (30117/30117), done.
# 
{% endhighlight %}

我们需要输出CEPH目录，以便在群集的每个节点都可以访问的二进制文件和必要的子目录。我们将采用NFS来实现它。

在ceph0主机（或任何有Ceph的源代码的主机），编辑/etc/exports文件。它应该有一个类似于以下行（假设你已经象我所所描述的那样，修改了/etc /hosts文件，否则，你将需要输入该文件中的IP地址）：

/usr/src/ceph ceph1(rw,async,no_subtree_check) ceph2(rw,async,no_subtree_check)

这个输出项目是非常简单。我没有考虑到安全问题在这里，因为这是一个非常简单的测试组，我们正在建立。接下来，重新启动（或启动，如果它从未开始）NFS服务如下。

{% highlight bash %}
#重新启动NFS服务
# service nfs restart
Shutting down NFS mountd:                                  [  OK  ]
Shutting down NFS daemon:                                  [  OK  ]
Shutting down NFS quotas:                                  [  OK  ]
Shutting down NFS services:                                [  OK  ]
Starting NFS services:                                     [  OK  ]
Starting NFS quotas:                                       [  OK  ]
Starting NFS daemon:                                       [  OK  ]
Starting NFS mountd:                                       [  OK  ]
{% endhighlight %}

现在在集群的其它节点上挂载此目录。
{% highlight bash %}
ceph1# mount -t nfs -o rw ceph0:/usr/src/ceph /usr/src/ceph
ceph2# mount -t nfs -o rw ceph0:/usr/src/ceph /usr/src/ceph
{% endhighlight %}

构建内核客户端

在我们组建Ceph之前，我们想要让内核客户端启动和运行。在本指南中，我将客户端构建到内核中。我们将在每个节点上做这个。首先，我们需要下载最新的内核源代码使用git。
{% highlight bash %}
# cd /usr/src/kernels
# git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
Initialize linux-2.6/.git
Initialized empty Git repository in /usr/src/kernels/linux-2.6/.git/
remote: Counting objects: 882421, done.
remote: Compressing objects: 100% (155150/155150), done.
remote: Total 882421 (delta 736090), reused 872174 (delta 725984)
Receiving objects: 100% (882421/882421), 209.92 MiB | 336 KiB/s, done.
Resolving deltas: 100% (736090/736090), done.
Checking out files: 100% (24247/24247), done.

# cd /usr/src/kernels/linux-2.6
# patch -p1 < /usr/src/ceph/src/kernel/kconfig.patch
patching file fs/Kconfig
Hunk #1 succeeded at 1557 with fuzz 2 (offset 38 lines).
patching file fs/Makefile
Hunk #1 succeeded at 122 (offset 4 lines).

# ln -s /usr/src/ceph/src/kernel fs/ceph
# ln -s /usr/src/ceph/src/include/ceph_fs.h fs/ceph/ceph_fs.h
# cd /usr/src/kernels/linux-2.6
# make mrproper
# make menuconfig
{% endhighlight %}
在这个菜单中，大量的配置选项将被提交给你。现在我会点你到一个深入的指导在这里，讨论更详细的配置选项等等而不是进入它。

确保您启用Ceph。它应该在文件系统 - >网络文件系统的第一个项目，如下所示。
   
现在，我们准备建立内核。这是只有几个命令，但需要相当一段时间取决于您的机器配置。
{% highlight bash %}
# cd /usr/src/kernels/linux-2.6
# make bzImage
# make modules
# make modules_install
# mkinitrd /boot/initrd-2.6.26.img 2.6.26
# cp /usr/src/kernels/linux-2.6/arch/i386/boot/bzImage /boot/bzImage-2.6.26
# cp /usr/src/kernels/linux-2.6/System.map /boot/System.map-2.6.26
# ln -s /boot/System.map-2.6.26 /boot/System.map
{% endhighlight %}

最后，我们需要配置GRUB引导程序能够启动新的内核。GRUB配置位于
/boot/brub/menu.lst

一旦完成了一个新的CentOS安装的编译，该文件应如下所示：
<pre>
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file

# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00
#          initrd /initrd-version.img
#boot=/dev/sda

default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz

hiddenmenu

title CentOS (2.6.18-53.el5)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-53.el5 ro root=/dev/VolGroup00/LogVol00
        initrd /initrd-2.6.18-53.el5.img

title LatestKernel (2.6.26)
        root (hd0,0)
        kernel /bzImage-2.6.26 ro root=/dev/VolGroup00/LogVol00
        initrd /initrd-2.6.26.img
</pre>
现在重新启动，选择你刚刚建立的内核。

安装BTRFS和创建BTRFS文件系统

在本指南中，我在每个OSD使用的是BTRFS，而不是ebofs。我只是存储节点上执行这些步骤–ceph1和ceph2。我将只展示一个节点的步骤，但你应该很容易在所有节点上重复它。Mercurial是SCM由BTRFS开发人员使用的。一些简单的安装此工具的后续说明在这里由Mercurial提供。

首先，我们获取最新的源：
{% highlight bash %}
# mkdir -p /usr/src/btrfs 
# cd /usr/src/btrfs 
# hg clone http://www.kernel.org/hg/btrfs/progs-unstable
 destination directory: progs-unstable 
requesting all changes adding changesets adding manifests adding file changes added 247 changesets with 888 changes to 58 files 
updating working directory 53 files updated, 0 files merged, 0 files removed, 0 files unresolved 
# hg clone http://www.kernel.org/hg/btrfs/kernel-unstable destination directory: kernel-unstable requesting all changes adding changesets adding manifests adding file changes added 650 changesets with 2137 changes to 64 files (+1 heads) updating working directory 54 files updated, 0 files merged, 0 files removed, 0 files unresolved
在获得的最新消息，需要打上由Sage Weilr制作的补丁，以便使BTRFS与Ceph正确工作。在这里来自Sage原始电子邮件附带这个补丁是可用的，但我有一个可用的补丁的本地副本，可以用如下的wget方式下载使用。
# cd /usr/src/btrfs/kernel-unstable
# wget http://www.ece.umd.edu/~posulliv/ceph/sage_btrfs.patch
# patch < sage_btrfs.patch

patching file ctree.h
patching file ioctl.c
patching file transaction.c
patching file transaction.h
#现在我们准备编译和安装BTRFS相关的所有东西：
# cd /usr/src/btrfs/kernel-unstable
# make
bash version.sh
make -C /lib/modules/`uname -r`/build M=`pwd` modules
make[1]: Entering directory `/usr/src/kernels/linux-2.6′
  CC [M]  /usr/src/btrfs/kernel-unstable/super.o
  CC [M]  /usr/src/btrfs/kernel-unstable/ctree.o
  CC [M]  /usr/src/btrfs/kernel-unstable/extent-tree.o
  CC [M]  /usr/src/btrfs/kernel-unstable/print-tree.o
  CC [M]  /usr/src/btrfs/kernel-unstable/root-tree.o
  CC [M]  /usr/src/btrfs/kernel-unstable/dir-item.o
  CC [M]  /usr/src/btrfs/kernel-unstable/hash.o
  CC [M]  /usr/src/btrfs/kernel-unstable/file-item.o
  CC [M]  /usr/src/btrfs/kernel-unstable/inode-item.o
  CC [M]  /usr/src/btrfs/kernel-unstable/inode-map.o
  CC [M]  /usr/src/btrfs/kernel-unstable/disk-io.o
  CC [M]  /usr/src/btrfs/kernel-unstable/transaction.o
  CC [M]  /usr/src/btrfs/kernel-unstable/bit-radix.o
  CC [M]  /usr/src/btrfs/kernel-unstable/inode.o
  CC [M]  /usr/src/btrfs/kernel-unstable/file.o
  CC [M]  /usr/src/btrfs/kernel-unstable/tree-defrag.o
  CC [M]  /usr/src/btrfs/kernel-unstable/extent_map.o
  CC [M]  /usr/src/btrfs/kernel-unstable/sysfs.o
  CC [M]  /usr/src/btrfs/kernel-unstable/struct-funcs.o
  CC [M]  /usr/src/btrfs/kernel-unstable/xattr.o
  CC [M]  /usr/src/btrfs/kernel-unstable/ordered-data.o
  CC [M]  /usr/src/btrfs/kernel-unstable/extent_io.o
  CC [M]  /usr/src/btrfs/kernel-unstable/volumes.o
  CC [M]  /usr/src/btrfs/kernel-unstable/async-thread.o
  CC [M]  /usr/src/btrfs/kernel-unstable/ioctl.o
  CC [M]  /usr/src/btrfs/kernel-unstable/locking.o
  CC [M]  /usr/src/btrfs/kernel-unstable/orphan.o
  CC [M]  /usr/src/btrfs/kernel-unstable/ref-cache.o
  CC [M]  /usr/src/btrfs/kernel-unstable/acl.o
  LD [M]  /usr/src/btrfs/kernel-unstable/btrfs.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /usr/src/btrfs/kernel-unstable/btrfs.mod.o
  LD [M]  /usr/src/btrfs/kernel-unstable/btrfs.ko
make[1]: Leaving directory `/usr/src/kernels/linux-2.6′
# insmod /usr/src/btrfs/kernel-unstable/btrfs.ko
# cd /usr/src/btrfs/progs-unstable
# make
# make install
{% endhighlight %}

接下来，我们需要在我们的磁盘上为创建BTRFS文件系统做好准备。我们将使用/dev /sdb。如果你没有另一个硬盘驱动器，关闭虚拟机并添加另一个硬盘驱动器这是非常容易的。现在，我们将使用fdisk来创建分区。这必须在所有存储节点完成。
{% highlight bash %}
# fdisk /dev/sdb
Command (m for help): n
Command action
	e   extended
	p   primary partition (1-4) p
Partition number (1-4): 1
First cylinder (1-130, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-130, default 130):
Using default value 130
Command (m for help): p
isk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         130     1044193+  83  Linux

Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
Syncing disks.
现在，我们已经准备好创建我们的BTRFS文件系统。遵循以下步骤：
# mkdir -p /mnt/btrfs
# mkfs.btrfs /dev/sdb1
# mount -t btrfs /dev/sdb1 /mnt/btrfs
# df -h
Filesystem                        Size   Used   Avail  Use%  Mounted on
/dev/mapper/VolGroup00-LogVol00   6.7G   5.7G   662M  90%      / 
/dev/sda1                         99M   19M   76M    20%      /boot
tmpfs                            192M     0   192M   0%       /dev/shm
/dev/sdb1                         1020M  40K  1020M   1%      /mnt/btrfs
ceph0:/usr/src/ceph                  6.7G   5.4G  1003M   85%     /usr/src/ceph
{% endhighlight %}

搭建Ceph

现在我们已经准备好执行搭建工作。因为我们对调试信息感兴趣，我们将在调试状态下编译。它仅需要在一个节点为上执行，因为该目录已经通过NFS输出。

{% highlight bash%}
# cd /usr/src/ceph
# ./autogen.sh
# CXXFLAGS="-g"
# ./configure
# make
# cd src
# mkdir out log
{% endhighlight %}

建立一个小型集群

现在我们可以开始设置我们的集群。第一步是设置监控器。
{% highlight bash %}
ceph0# cd /usr/src/ceph/src
ceph0# ./monmaptool –create –clobber –add 192.168.221.137:12345 –print .ceph_monmap
ceph0# ./mkmonfs –clobber mondata/mon0 –mon 0 –monmap .ceph_monmap
{% endhighlight %}

现在，我们第一次启动监控器。我们启用将在/usr/src/ceph/src/log 和/usr/src/ceph/src/out目录产生的广泛的日志记录。
{% highlight bash %}
ceph0# ./cmon mondata/mon0 -d –debug_mon 10 –debug_ms 1
{% endhighlight %}
接下来，我们建立了OSD集群视图，它是作为一个合约定义，存储集群的组成设备的分层描述。对于这个简单的设置，我有2个存储节点–ceph1和ceph2。在创建群集的视图之后，我们必须通知的视图的监控器。
{% highlight bash %}
ceph0# ./osdmaptool –clobber –createsimple .ceph_monmap 2 –print .ceph_osdmap
{% endhighlight %}

{% highlight bash %}
ceph0# ./cmonctl osd setmap -i .ceph_osdmap
{% endhighlight %}
现在我们转移到存储节点。在每个存储节点上，我们首先初始化各个对象存储。
{% highlight bash %}
ceph1# mkdir -p /mnt/btrfs/osd0
{% endhighlight %}

{% highlight bash %}
ceph2# mkdir -p /mnt/btrfs/osd1
{% endhighlight %}

{% highlight bash %}
ceph1# cd /usr/src/ceph/src
ceph1# ./cosd –mkfs_for_osd 0 /mnt/btrfs/osd0
{% endhighlight %}

{% highlight bash %}
ceph2# cd /usr/src/ceph/src
ceph2# ./cosd –mkfs_for_osd 1 /mnt/btrfs/osd1
{% endhighlight %}

接下来，在每个存储节点启动OSD守护进程。同样地，我们将启用所有的记录，以使我们可以解决任何出现的问题。日志文件将被放置在同一目录，前面提到的。
{% highlight bash %}
ceph1# cd /usr/src/ceph/src
ceph1# ./cosd /mnt/btrfs/osd0 /mnt/btrfs/osd0 -d –debug_osd 10
{% endhighlight %}

{% highlight bash %}
ceph2# cd /usr/src/ceph/src
ceph2# ./cosd /mnt/btrfs/osd1 /mnt/btrfs/osd1 -d –debug_osd 10
{% endhighlight %}
最后，我们在ceph0启动元数据服务器。
{% highlight bash %}
ceph0# cd /usr/src/ceph/src

ceph0# ./cmds –debug_ms 1 –debug_mds 10 -d
{% endhighlight %}

验证群集
现在，我们要验证的文件系统已经启动并工作。
{% highlight bash %}
ceph0# cd /usr/src/ceph/src

ceph0# ./cmonctl osd stat
mon0 <- ’osd stat’
mon0 -> ’e4: 2 osds: 2 up, 2 in’ (0)

ceph0# ./cmonctl pg stat
mon0 <- ’pg stat’
mon0 -> ’v27: 1152 pgs: 1152 active+clean; 4 MB used, 2035 MB / 2039 MB free’ (0)

ceph0# ./cmonctl mds stat
mon0 <- ’mds stat’
mon0 -> ’e3: 1 nodes: 1 up:active’ (0)

ceph0# ./csyn –syn makedirs 1 1 1 –syn walk
starting csyn at 0.0.0.0:57466/13601/0
mounting and starting 1 syn client(s)
waiting for client(s) to finish

10000000000 drwxr-xr-x  1     0     0        0 Sat Aug  2 04:24:15 2008 /syn.0.0
10000000002 drwxr-xr-x  1     0     0        0 Sat Aug  2 04:24:15 2008 /syn.0.0/dir.0
10000000001 -rw-r–r–  1     0     0        0 Sat Aug  2 04:24:15 2008 /syn.0.0/file.0
10000000003 -rw-r–r–  1     0     0        0 Sat Aug  2 04:24:15 2008 /syn.0.0/dir.0/file.0
{% endhighlight %}

如果您没有看到类似上面的输出信息，那么是时候开始排除故障了！

使用内核客户端

既然我们尽了所有的努力创建内核客户端，我们不妨利用它。我们将在2个存储节点挂载CEPH文件系统。这是很简单的事情。
{% highlight bash %}
# mkdir -p /mnt/ceph 
# mount -t ceph 192.168.221.137:/ /mnt/ceph/ 
# df -h 
Filesystem            Size  Used Avail Use% Mounted on 
/dev/mapper/VolGroup00-LogVol00                       6.7G  5.3G  1.1G  84% / 
/dev/sda1              99M   19M   76M  20% /boot 
tmpfs                 192M     0  192M   0% /dev/shm 
/dev/sdb1            1020M  3.9M 1016M   1% /mnt/btrfs 
192.168.221.137:/usr/src/ceph                       6.7G  5.4G  984M  85% /usr/src/ceph 
192.168.221.137:/     2.0G  7.0M  2.0G   1% /mnt/ceph 
# ls -l /mnt/ceph 
total 1 
drwxr-xr-x 1 root root  0 Aug  2 05:01 syn.0.0 
# ls -l /mnt/ceph/syn.0.0 
total 0 
drwxr-xr-x 1 root root 0 Aug  2 04:24 dir.0 
-rw-r–r– 1 root root 0 Aug  2 04:24 file.0
{% endhighlight %}

测试文件系统
iozone 是一个文件系统基准测试工具。下载并运用它。它是一种很好的工具，强调一个文件系统。我没有做过的分布式文件系统方面也与它多，所以我还是搞乱它。要安装它是很简单不过。在下面的输出，我是AMD64平台上编译。

{% highlight bash %}
# cd /usr/src/
# wget http://www.iozone.org/src/current/iozone3_308.tar
# tar xvf iozone3_308.tar
# cd /usr/src/iozone3_308/src/current
# make linux-AMD64
# ./iozone
        Usage: For usage information type iozone -h

# ./iozone -g 1024M -f /mnt/ceph/iozone-file.tmp
        Iozone: Performance Test of File I/O
                Version $Revision: 3.308 $
                Compiled for 64 bit mode.
                Build: linux-AMD64
        Contributors:William Norcott, Don Capps, Isom Crawford, Kirby Collins                       Al Slater, Scott Rhine, Mike Wisner, Ken Goss                       Steve Landherr, Brad Smith, Mark Kelly, Dr. Alain CYR,
                    Randy Dunlap, Mark Montague, Dan Million, Gavin Brebner,                       Jean-Marc Zucconi, Jeff Blomberg, Benny Halevy,
                     Erik Habbinga, Kris Strecker, Walter Wong, Joshua Root.
          Run began: Sat Aug  2 05:27:50 2008
        Using maximum file size of 1048576 kilobytes.
          Command line used: ./iozone -g 1024M -f /mnt/ceph/iozone-file.tmp
          Output is in Kbytes/sec
          Time Resolution = 0.000001 seconds.
          Processor cache size set to 1024 Kbytes.
          Processor cache line size set to 32 bytes.
          File stride size set to 17 * record size.                                                              random  random    bkwd   record   stride
              KB  reclen   write rewrite    read    reread    read   write    read  rewrite     read   fwrite frewrite   fread  freread              
     512       4  135952  585814  1854787  3481620 2600470 1672748  595397  2007358  1712772    95665  1815584 1968713  3325278
iozone test complete.
{% endhighlight %}
