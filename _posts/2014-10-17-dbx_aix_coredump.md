---
layout: post
title: "使用DBX分析AIX 下的 CoreDump"
categories: c/c++
tags: [dbx, 调试core, coredump]
date: 2014-10-17 11:20:57
---

<p style="padding: 0px 0px 15px; margin: 0px;">最近工作涉及到分析core dump文件，发现这个好帖，就当仁不让地转到偶博客了O(∩_∩)O~</p><p style="padding: 0px 0px 15px; margin: 0px;">&nbsp;</p><p style="padding: 0px 0px 15px; margin: 0px;">PS:</p><p style="padding: 0px 0px 15px; margin: 0px;">Where can you get dbx?<br style="padding: 0px; margin: 0px;">It is part of bos.adt.debug<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"># lslpp -w /usr/bin/dbx<br style="padding: 0px; margin: 0px;">File Fileset Type<br style="padding: 0px; margin: 0px;">-------------------------------------------<br style="padding: 0px; margin: 0px;">/usr/bin/dbx bos.adt.debug Symlink<br style="padding: 0px; margin: 0px;">&nbsp;</p><p style="padding: 0px 0px 15px; margin: 0px;">&nbsp;</p><p style="padding: 0px 0px 15px; margin: 0px;">以下转自：http://www.aixchina.net/?6141/viewspace-18882</p><p style="padding: 0px 0px 15px; margin: 0px;">&nbsp;</p><h1>I core dump 分析入门</h1><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N100CD" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">环境变量设置</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">可以通过 /etc/security/limits 文件对各用户的基本配置参数包括 core 大小进行限制。或者通过 ulimit 更改当前环境下的 core 大小限制。</p><p style="padding: 0px 0px 15px; margin: 0px;">默认情况下，应用进程生成 core dump 时都使用文件名 core。为了避免同一工作目录下的进程 core 相互覆盖，可以定义环境变量 CORE_NAMING=true，然后启动进程，这样将生成名为 core.pid.ddhhmmss 的文件。可以使用 file core 命令查看 core 是哪个进程产生的。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">默认情况下，应用进程 dump 时会包含所有的共享内存，如果 dump 时想排除共享内存内容，可以在启动进程之前设置环境变量 CORE_NOSHM=true.</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">系统有一个参数 fullcore 用于控制是否在程序 coredump 时生成完整的 core。为避免信息丢失，建议打开 fullcore。可以使用 lsattr –El sys0 查询是否将 fullcore 打开，使用 chdev -l sys0 -a fullcore=true 将 fullcore 状态更改为打开。也可以在程序内部调用 sigaction 例程设置 fullcore，参考如下测试程序：</p><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><a name="N100E3" style="padding: 0px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">fullcore 设置示例&nbsp;</strong></a><br style="padding: 0px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 495px;">                <br style="padding: 0px; margin: 0px;">//test.C<br style="padding: 0px; margin: 0px;">#include &lt;iostream&gt;<br style="padding: 0px; margin: 0px;">#include &lt;signal.h&gt; <br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">int main(int argc, char* argv[])<br style="padding: 0px; margin: 0px;">{<br style="padding: 0px; margin: 0px;"> char str[10];<br style="padding: 0px; margin: 0px;"> struct sigaction s;<br style="padding: 0px; margin: 0px;"> s.sa_handler = SIG_DFL; <br style="padding: 0px; margin: 0px;"> s.sa_mask.losigs = 0;<br style="padding: 0px; margin: 0px;"> s.sa_mask.hisigs = 0;<br style="padding: 0px; margin: 0px;"> s.sa_flags = SA_FULLDUMP;<br style="padding: 0px; margin: 0px;"> sigaction(SIGSEGV,&amp;s,(struct sigaction *) NULL); <br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> std::cout &lt;&lt; " input str!\n" &lt;&lt; std::endl;<br style="padding: 0px; margin: 0px;"> std::cin &gt;&gt; str;<br style="padding: 0px; margin: 0px;"> return 0;<br style="padding: 0px; margin: 0px;">}<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N100EA" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">寻找 core dump</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">应用进程的 core 产生在其当前工作目录下，可以在应用程序内部使用 chdir 函数切换当前工作目录。使用 procwdx 命令可以查看进程的当前工作目录。系统的 core 生成在 lg_dumplv 下，并在重启时转移到 /var/adm/ras/ 目录下（如果有足够空间的话，否则继续保留在 lg_dumplv，并随时有可能被覆盖）。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">可以使用 errpt -a 查看标识 C0AA5338 SYSDUMP（系统 core）、B6048838 CORE_DUMP（进程 core）的详细错误信息，获取生成 core 的进程以及 core 文件位置。使用 snap –ac 收集系统的 dump 信息。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N100F6" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">core dump 信息收集</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;">如果可能 , 直接在发生 coredump 的机器上用 dbx 分析出结果 , 这样是最方便的分析方法 . 这种情况下注意不要直接以 root 用户登录然后用 dbx 分析 , 而必须在应用程序所属的用户下进行此操作 , 因为 core 可能需要依赖应用程序运行时对应环境下的某些库 , 这样就要借助应用程序的环境变量 .</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">如果需取回生产机上的 core 信息在实验室分析 , 则需要搜集一些相关信息 . 进程 core 分析一般至少需要依赖应用可执行程序，有时还需要包括一些运行时动态库信息。如果需要收集 core 相关的完整信息，可运行 snapcore &lt;core 路径以及名称 &gt; &lt; 可执行文件以及名称 &gt;，例如 snapcore ./core ./a.out，然后在 /tmp/snapcore 下取下相应的 .pax.Z 文件。</p><p style="padding: 0px 0px 15px; margin: 0px;">正常的收集过程应该如下 :</p><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><a name="N10109" style="padding: 0px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">snap core 收集过程&nbsp;</strong></a><br style="padding: 0px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 675px;">                <br style="padding: 0px; margin: 0px;"># snapcore ./core ./a.out<br style="padding: 0px; margin: 0px;">Core file "./core" created by "a.out"<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">pass1() in progress ....<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Calculating space required .<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Total space required is 14130 kbytes ..<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Checking for available space ...<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Available space is 807572 kbytes<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">pass1 complete.<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">pass2() in progress ....<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Collecting fileset information .<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Collecting error report of CORE_DUMP errors ..<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Creating readme file ..<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Creating archive file ...<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> Compressing archive file ....<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">pass2 completed.<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">Snapcore completed successfully. Archive created in /tmp/snapcore.<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"># cd /tmp/snapcore<br style="padding: 0px; margin: 0px;"># ls<br style="padding: 0px; margin: 0px;">snapcore_352276.pax.Z<br style="padding: 0px; margin: 0px;"># uncompress snapcore_352276.pax.Z<br style="padding: 0px; margin: 0px;"># ls<br style="padding: 0px; margin: 0px;">snapcore_352276.pax<br style="padding: 0px; margin: 0px;"># pax -r -f snapcore_352276.pax<br style="padding: 0px; margin: 0px;"># ls 注意需要保证有类似如下文件 ( 可执行文件，/core/errpt/lslpp/usr 目录等 ):<br style="padding: 0px; margin: 0px;">README errpt.out usr<br style="padding: 0px; margin: 0px;">a.out lslpp.out<br style="padding: 0px; margin: 0px;">core snapcore_352276.pax<br style="padding: 0px; margin: 0px;">#<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N10110" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px; font-weight: bold;">II 使用 dbx 分析 core dump 的例子</span></span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">dbx 是 AIX 下基于命令行界面的源码级调试工具。本文档只提供一些基本的 dbx 分析指令，详细内容请参考“General Programming Concepts: Writing and Debugging Programs”关于 dbx 的描述。</p><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><a name="N1011D" style="padding: 0px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">初步分析&nbsp;</strong></a><br style="padding: 0px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 356px;">                <br style="padding: 0px; margin: 0px;">#dbx &lt;program name&gt; core<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">示例：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 663px;"># dbx ./test core<br style="padding: 0px; margin: 0px;">Type 'help' for help.<br style="padding: 0px; margin: 0px;">warning: The core file is not a fullcore. Some info may<br style="padding: 0px; margin: 0px;">not be available.<br style="padding: 0px; margin: 0px;">[using memory image in core]<br style="padding: 0px; margin: 0px;">reading symbolic information ...warning: no source compiled with -g<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">Segmentation fault in raise at 0xd022e1e4<br style="padding: 0px; margin: 0px;">0xd022e1e4 (raise+0x40) 80410014 lwz r2,0x14(r1)<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">显示出 core 发生时，当前进程执行到的位置（-g 编译的情况下能够看到具体的行）：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 356px;">(dbx) where<br style="padding: 0px; margin: 0px;">raise(??) at 0xd022e1e4<br style="padding: 0px; margin: 0px;">main(0x1, 0x2ff22d48) at 0x100019c4<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">注意：</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">如果分析的是异地 core 文件，需要采用 snapcore 收集相关 core 信息。对于依赖链接库的情况，注意需要增加&nbsp;</strong><code style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">-p ldpath=newpath:...&nbsp;</span></code><strong style="padding: 0px; margin: 0px;">重新设置链接库路径（只有所有依赖的库都已经被链接，才能完整的复现 core</strong>&nbsp;<strong style="padding: 0px; margin: 0px;">dump 故障现场），参考 dbx 的帮助文档获取更多信息。</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 663px;"># cd /tmp/snapcore<br style="padding: 0px; margin: 0px;"># dbx –p /=./ a.out core<br style="padding: 0px; margin: 0px;">Type 'help' for help.<br style="padding: 0px; margin: 0px;">[using memory image in core]<br style="padding: 0px; margin: 0px;">reading symbolic information ...warning: no source compiled with -g<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">IOT/Abort trap in raise at 0xd01f4f60<br style="padding: 0px; margin: 0px;">0xd01f4f60 (raise+0x40) 80410014 lwz r2,0x14(r1) <br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">列举源码信息</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">列举程序源码（list，需要在运行 dbx 命令时使用 -I 指明源码搜索路径，并使用 -g 编译）或者汇编码（listi）：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 475px;"> (dbx) listi main<br style="padding: 0px; margin: 0px;">0x10001924 (main) 7c0802a6 mflr r0<br style="padding: 0px; margin: 0px;">0x10001928 (main+0x4) bfa1fff4 stmw r29,-12(r1)<br style="padding: 0px; margin: 0px;">0x1000192c (main+0x8) 90010008 stw r0,0x8(r1)<br style="padding: 0px; margin: 0px;">0x10001930 (main+0xc) 9421ffa0 stwu r1,-96(r1)<br style="padding: 0px; margin: 0px;">0x10001934 (main+0x10) 83e20064 lwz r31,0x64(r2)<br style="padding: 0px; margin: 0px;">0x10001938 (main+0x14) 90610078 stw r3,0x78(r1)<br style="padding: 0px; margin: 0px;">0x1000193c (main+0x18) 9081007c stw r4,0x7c(r1)<br style="padding: 0px; margin: 0px;">0x10001940 (main+0x1c) 83a20068 lwz r29,0x68(r2)<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">列举变量内容</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">示例代码：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 485px;">#include &lt;iostream&gt;<br style="padding: 0px; margin: 0px;">#include &lt;signal.h&gt;<br style="padding: 0px; margin: 0px;">int g_test =0;<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">int testfunc(int &amp;para)<br style="padding: 0px; margin: 0px;">{<br style="padding: 0px; margin: 0px;"> para++;<br style="padding: 0px; margin: 0px;"> return 0;<br style="padding: 0px; margin: 0px;">}<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">int main(int argc, char* argv[])<br style="padding: 0px; margin: 0px;">{<br style="padding: 0px; margin: 0px;"> struct sigaction s;<br style="padding: 0px; margin: 0px;"> s.sa_handler = SIG_DFL;<br style="padding: 0px; margin: 0px;"> s.sa_mask.losigs = 0;<br style="padding: 0px; margin: 0px;"> s.sa_mask.hisigs = 0;<br style="padding: 0px; margin: 0px;"> s.sa_flags = SA_FULLDUMP;<br style="padding: 0px; margin: 0px;"> sigaction(SIGSEGV,&amp;s,(struct sigaction *) NULL);<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> char str[10];<br style="padding: 0px; margin: 0px;"> g_test =0;<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"> testfunc(g_test);<br style="padding: 0px; margin: 0px;"> abort();<br style="padding: 0px; margin: 0px;">}<br style="padding: 0px; margin: 0px;"># xlC test.C -g<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">以全局变量 g_test 举例：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#print g_test 显示 g_test 的取值</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#print sizeof(g_test) 显示 g_test 的大小</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#whatis g_test 显示 g_test 的类型</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#print &amp;g_test 显示 g_test 的地址</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#&amp;g_test/16x 显示从 g_test 的地址开始处，连续 16 个 WORD（?byte）的取值</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">如果没有使用 -g 编译，则不能动态获取 g_test 的类型、大小等信息，但能够得到 g_test 的地址，并查询该地址所在区域存储空间的值。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">例如：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 504px;"># ./a.out<br style="padding: 0px; margin: 0px;">IOT/Abort trap(coredump)<br style="padding: 0px; margin: 0px;"># dbx ./a.out core<br style="padding: 0px; margin: 0px;">Type 'help' for help.<br style="padding: 0px; margin: 0px;">[using memory image in core]<br style="padding: 0px; margin: 0px;">reading symbolic information ...<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">IOT/Abort trap in raise at 0xd03365bc<br style="padding: 0px; margin: 0px;">0xd03365bc (raise+0x40) 80410014 lwz r2,0x14(r1)<br style="padding: 0px; margin: 0px;">(dbx) print g_test<br style="padding: 0px; margin: 0px;">1<br style="padding: 0px; margin: 0px;">(dbx) whatis g_test<br style="padding: 0px; margin: 0px;">int g_test;<br style="padding: 0px; margin: 0px;">(dbx) print sizeof(g_test)<br style="padding: 0px; margin: 0px;">4<br style="padding: 0px; margin: 0px;">(dbx) print &amp;g_test<br style="padding: 0px; margin: 0px;">0x20000428<br style="padding: 0px; margin: 0px;">(dbx) &amp;g_test/16x<br style="padding: 0px; margin: 0px;">0x20000428: 0000 0001 0000 0000 0000 0000 0000 0000<br style="padding: 0px; margin: 0px;">0x20000438: 0000 0000 0000 0000 0000 0000 0000 0000<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">列举寄存器内容</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">列举寄存器内容：</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) registers</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">如下模拟一个简单的 core dump，对 0 地址赋值引发 core dump 的问题：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 663px;"># dbx ./a.out core<br style="padding: 0px; margin: 0px;">Type 'help' for help.<br style="padding: 0px; margin: 0px;">warning: The core file is not a fullcore. Some info may<br style="padding: 0px; margin: 0px;">not be available.<br style="padding: 0px; margin: 0px;">[using memory image in core]<br style="padding: 0px; margin: 0px;">reading symbolic information ...warning: no source compiled with -g<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">Segmentation fault in main at 0x10000348<br style="padding: 0px; margin: 0px;">0x10000348 (main+0x18) 90640000 stw r3,0x0(r4)<br style="padding: 0px; margin: 0px;">(dbx) where<br style="padding: 0px; margin: 0px;">main(0x1, 0x2ff22ccc) at 0x10000348<br style="padding: 0px; margin: 0px;">(dbx) registers<br style="padding: 0px; margin: 0px;"> $r0:0x00000000 $stkp:0x2ff22bf0 $toc:0x20000414 $r3:0x00000012<br style="padding: 0px; margin: 0px;"> $r4:0x00000000 $r5:0x2ff22cd4 $r6:0xdeadbeef $r7:0x2ff22ff8<br style="padding: 0px; margin: 0px;"> $r8:0x00000000 $r9:0x04030000 $r10:0xf0577538 $r11:0xdeadbeef<br style="padding: 0px; margin: 0px;"> $r12:0xdeadbeef $r13:0xdeadbeef $r14:0x00000001 $r15:0x2ff22ccc<br style="padding: 0px; margin: 0px;"> $r16:0x2ff22cd4 $r17:0x00000000 $r18:0xdeadbeef $r19:0xdeadbeef<br style="padding: 0px; margin: 0px;"> $r20:0xdeadbeef $r21:0xdeadbeef $r22:0xdeadbeef $r23:0xdeadbeef<br style="padding: 0px; margin: 0px;"> $r24:0xdeadbeef $r25:0xdeadbeef $r26:0xdeadbeef $r27:0xdeadbeef<br style="padding: 0px; margin: 0px;"> $r28:0xdeadbeef $r29:0xdeadbeef $r30:0xdeadbeef $r31:0xdeadbeef<br style="padding: 0px; margin: 0px;"> $iar:0x10000348 $msr:0x0000d0b2 $cr:0x22282489 $link:0x100001b4<br style="padding: 0px; margin: 0px;"> $ctr:0xdeadbeef $xer:0x20000020<br style="padding: 0px; margin: 0px;"> Condition status = 0:e 1:e 2:e 3:l 4:e 5:g 6:l 7:lo<br style="padding: 0px; margin: 0px;"> [unset $noflregs to view floating point registers]<br style="padding: 0px; margin: 0px;"> [unset $novregs to view vector registers]<br style="padding: 0px; margin: 0px;">in main at 0x10000348<br style="padding: 0px; margin: 0px;">0x10000348 (main+0x18) 90640000 stw r3,0x0(r4)<br style="padding: 0px; margin: 0px;">(dbx) print $r3<br style="padding: 0px; margin: 0px;">0x00000012<br style="padding: 0px; margin: 0px;">(dbx) print $r4<br style="padding: 0px; margin: 0px;">(nil)<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">这个例子比较简单，从最后汇编指令“stw r3,0x0(r4)”就可以简单的看到程序 core dump 是因为向 0 地址（0+r4）存入 18（r3 寄存器值）造成。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">查看多线程相关信息</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">如果以下环境变量采用默认的 OFF 值，则系统会完全禁止适当的调试列表，这意味着 dbx 命令将显示不出任何对象：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">AIXTHREAD_MUTEX_DEBUG</p><p style="padding: 0px 0px 15px; margin: 0px;">AIXTHREAD_COND_DEBUG</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">AIXTHREAD_RWLOCK_DEBUG</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">可以使用</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">export AIXTHREAD_MUTEX_DEBUG=ON</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">打开 AIXTHREAD_MUTEX_DEBUG。</p><ul style="padding: 0px; margin: 0px;"><li style="padding: 0px; margin: 0px 0px 0px 20px; list-style-type: none;">查看线程信息<p style="padding: 0px 0px 15px; margin: 0px;">(dbx) print $t1 // 打印 t1 线程的基本信息</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) attribute</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) condition</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) mutex</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) rwlock</p><p style="padding: 0px 0px 15px; margin: 0px;">(dbx) thread</p><p style="padding: 0px 0px 15px; margin: 0px;">例如：</p><p style="padding: 0px 0px 15px; margin: 0px;">(thread_id = 1, state_u = 4, priority = 60, policy = other, attributes = 0x20001078)</p></li><li style="padding: 0px; margin: 0px 0px 0px 20px; list-style-type: none;">切换当前线程（默认当前线程为收到 core 触发信号所在线程）<p style="padding: 0px 0px 15px; margin: 0px;">(dbx) thread current [tid]</p><p style="padding: 0px 0px 15px; margin: 0px;">例如（&gt; 表明 core dump 时的当前线程）：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 683px;">(dbx)thread<br style="padding: 0px; margin: 0px;"> thread state-k wchan state-u k-tid mode held scope function<br style="padding: 0px; margin: 0px;"> $t1 wait 0x31bbb558 running 10321 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t2 wait 0x311fb958 running 6275 k no pro _ptrgl <br style="padding: 0px; margin: 0px;">&gt;$t3 run running 6985 k no pro _p_nsleep <br style="padding: 0px; margin: 0px;"> $t4 wait 0x31bbbb18 running 6571 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t5 wait 0x311fb9d8 running 7999 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t6 wait 0x31bf8f98 running 8257 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t7 wait 0x311fba18 running 8515 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t8 wait 0x311fb7d8 running 8773 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t9 wait 0x311fbb18 running 9031 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t10 wait 0x311fb898 running 9547 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t11 wait 0x311fb818 running 9805 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t12 wait 0x311fba58 running 10063 k no pro _ptrgl <br style="padding: 0px; margin: 0px;"> $t13 wait 0x311fb8d8 running 10579 k no pro _ptrgl <br style="padding: 0px; margin: 0px;">(dbx) thread current 3<br style="padding: 0px; margin: 0px;">(dbx) where<br style="padding: 0px; margin: 0px;">_p_nsleep(??, ??) at 0xd005f740<br style="padding: 0px; margin: 0px;">raise.nsleep(??, ??) at 0xd022de3c<br style="padding: 0px; margin: 0px;">sleep(??) at 0xd0260344<br style="padding: 0px; margin: 0px;">helper(??) at 0x100005ac<br style="padding: 0px; margin: 0px;">(dbx) thread current 4<br style="padding: 0px; margin: 0px;">warning: Thread is in kernel mode, not all registers can be accessed.<br style="padding: 0px; margin: 0px;">(dbx) where<br style="padding: 0px; margin: 0px;">ptrgl._ptrgl() at 0xd020e470<br style="padding: 0px; margin: 0px;">raise.nsleep(??, ??) at 0xd022de3c<br style="padding: 0px; margin: 0px;">raise.nsleep(??, ??) at 0xd022de3c<br style="padding: 0px; margin: 0px;">sleep(??) at 0xd0260344<br style="padding: 0px; margin: 0px;">helper(??) at 0x100005ac<br style="padding: 0px; margin: 0px;">(dbx) <br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><br style="padding: 0px; margin: 0px;"></li></ul><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">core dump 分析的局限性</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">不要期待能依赖 core dump 分析解决所有的问题，下面是一个简单的模拟缓冲区溢出的例子，在这个例子中由于缓冲区溢出覆盖了调用栈信息，从而完全丢失了定位依据：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 702px;">root@/tmp#&gt;xlC test.C -g -o test2<br style="padding: 0px; margin: 0px;">root@/tmp#&gt;<br style="padding: 0px; margin: 0px;">root@/tmp#&gt;./test<br style="padding: 0px; margin: 0px;"> input str!<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">012345678901234567890123456789<br style="padding: 0px; margin: 0px;">Segmentation fault(coredump)<br style="padding: 0px; margin: 0px;">root@/tmp#&gt;dbx ./test2 core<br style="padding: 0px; margin: 0px;">Type 'help' for help.<br style="padding: 0px; margin: 0px;">[using memory image in core]<br style="padding: 0px; margin: 0px;">reading symbolic information ...<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">Segmentation fault in test2. at 0x34353634<br style="padding: 0px; margin: 0px;">0x34353634 (???) warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">(dbx) where<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353630 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353630 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353630 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353630 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x34353634 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x36373841 from core<br style="padding: 0px; margin: 0px;">test2.() at 0x34353634<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x36373839 from core<br style="padding: 0px; margin: 0px;">warning: Unable to access address 0x36373839 from core<br style="padding: 0px; margin: 0px;">(dbx)<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="100%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><img alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" title="点击图片可在新窗口打开" style="padding: 0px; margin: 0px; vertical-align: top; cursor: pointer;" height="1" width="650"><br style="padding: 0px; margin: 0px;"><img src="http://www.ibm.com/i/c.gif" alt="" title="点击图片可在新窗口打开" style="padding: 0px; margin: 0px; vertical-align: top; cursor: pointer;" height="6" border="0" width="8"></td></tr></tbody></table><table style="padding: 0px; margin: 0px auto; font-size: 12px;" align="right" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;" align="right"><td style="padding: 0px; margin: 0px;"><img alt="" src="http://www.ibm.com/i/c.gif" title="点击图片可在新窗口打开" style="padding: 0px; margin: 0px; vertical-align: top; cursor: pointer;" height="4" width="100%"><br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="3. 系统 dump 分析 |outline" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">系统 dump 分析</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N101FD" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">环境变量设置</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">可以通过“sysdumpdev –l”查看系统当前的 dump 配置信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 356px;">root@/#&gt;sysdumpdev -l<br style="padding: 0px; margin: 0px;">primary /dev/hd6<br style="padding: 0px; margin: 0px;">secondary /dev/sysdumpnull<br style="padding: 0px; margin: 0px;">copy directory /var/adm/ras<br style="padding: 0px; margin: 0px;">forced copy flag TRUE<br style="padding: 0px; margin: 0px;">always allow dump FALSE<br style="padding: 0px; margin: 0px;">dump compression ON<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">注意旧版本的 AIX “always allow dump”可能默认为关闭；为方便系统 crash 时问题定位，建议打开，可使用命令 sysdumpdev –K 或者使用 smitty -&gt; System Environments-&gt; Change / Show Characteristics of System Dump 菜单设置。</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">sysdumpdev –L 获得最近系统产生的 dump 的相关统计信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 425px;">#&gt;sysdumpdev -L<br style="padding: 0px; margin: 0px;">0453-039<br style="padding: 0px; margin: 0px;">Device name: /dev/hd6<br style="padding: 0px; margin: 0px;">Major device number: 10<br style="padding: 0px; margin: 0px;">Minor device number: 2<br style="padding: 0px; margin: 0px;">Size: 18885120 bytes<br style="padding: 0px; margin: 0px;">Uncompressed Size: 113724523 bytes<br style="padding: 0px; margin: 0px;">Date/Time: Sat Jul 21 14:20:22 BEIST 2007<br style="padding: 0px; margin: 0px;">Dump status: 0<br style="padding: 0px; margin: 0px;">dump completed successfully<br style="padding: 0px; margin: 0px;">Dump copy filename: /var/adm/ras/vmcore.2.Z<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">为保证系统出现 crash 时，dump device 能够保存下 dump 信息，需要合理的配置 dump device 的大小，可以使用 sysdumpdev –e 估计系统 dump 需要的空间。一般推荐的 dump device 值大小为 sysdumpdev –e 估计值的 1.5 倍。</p><p style="padding: 0px 0px 15px; margin: 0px;"><a name="N10219" style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;">环境变量设置</span></a></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">本文档只提供一些基本的 dump 分析指令，详细内容请参考“KDB kernel debugger and kdb command ”。</p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">初步分析</strong></p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">kdb 对 dump 文件分析需要借助于产生 dump 的内核文件 /unix，一般 snap –ac 会对此文件进行收集。初步命令如下：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">#kdb ./dump ./unix</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">示例：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 782px;">#kdb ./dump ./unix<br style="padding: 0px; margin: 0px;">The specified kernel file is a 64-bit kernel<br style="padding: 0px; margin: 0px;">./dump mapped from @ 700000000000000 to @ 70000007da53bd5<br style="padding: 0px; margin: 0px;">Preserving 1317350 bytes of symbol table<br style="padding: 0px; margin: 0px;">First symbol __mulh<br style="padding: 0px; margin: 0px;">Component Names:<br style="padding: 0px; margin: 0px;"> 1) minidump [2 entries]<br style="padding: 0px; margin: 0px;"> 2) dmp_minimal [9 entries]<br style="padding: 0px; margin: 0px;"> 3) proc [481 entries]<br style="padding: 0px; margin: 0px;"> 4) thrd [1539 entries]<br style="padding: 0px; margin: 0px;"> 5) rasct [1 entries]<br style="padding: 0px; margin: 0px;"> 6) ldr [2 entries]<br style="padding: 0px; margin: 0px;"> 7) errlg [3 entries]<br style="padding: 0px; margin: 0px;"> 8) mtrc [26 entries]<br style="padding: 0px; margin: 0px;"> 9) lfs [1 entries]<br style="padding: 0px; margin: 0px;">10) bos [2 entries]<br style="padding: 0px; margin: 0px;">11) ipc [7 entries]<br style="padding: 0px; margin: 0px;">12) vmm [13 entries]<br style="padding: 0px; margin: 0px;">13) alloc_kheap [256 entries]<br style="padding: 0px; margin: 0px;">14) alloc_other [26 entries]<br style="padding: 0px; margin: 0px;">15) rtastrc [8 entries]<br style="padding: 0px; margin: 0px;">16) efcdd [20 entries]<br style="padding: 0px; margin: 0px;">17) eidedd [1 entries]<br style="padding: 0px; margin: 0px;">18) sisraid [2 entries]<br style="padding: 0px; margin: 0px;">19) aixpcm [5 entries]<br style="padding: 0px; margin: 0px;">20) scdisk [11 entries]<br style="padding: 0px; margin: 0px;">21) lvm [2 entries]<br style="padding: 0px; margin: 0px;">22) jfs2 [1 entries]<br style="padding: 0px; margin: 0px;">23) tty [4 entries]<br style="padding: 0px; margin: 0px;">24) netstat [10 entries]<br style="padding: 0px; margin: 0px;">25) goent_dd [7 entries]<br style="padding: 0px; margin: 0px;">26) scsidisk [11 entries]<br style="padding: 0px; margin: 0px;">27) efscsi [5 entries]<br style="padding: 0px; margin: 0px;">28) dump_statistics [1 entries]<br style="padding: 0px; margin: 0px;">Component Dump Table has 2456 entries<br style="padding: 0px; margin: 0px;"> START END &lt;name&gt;<br style="padding: 0px; margin: 0px;">0000000000001000 0000000003BBA050 start+000FD8<br style="padding: 0px; margin: 0px;">F00000002FF47600 F00000002FFDC920 __ublock+000000<br style="padding: 0px; margin: 0px;">000000002FF22FF4 000000002FF22FF8 environ+000000<br style="padding: 0px; margin: 0px;">000000002FF22FF8 000000002FF22FFC errno+000000<br style="padding: 0px; margin: 0px;">F100070F00000000 F100070F10000000 pvproc+000000<br style="padding: 0px; margin: 0px;">F100070F10000000 F100070F18000000 pvthread+000000<br style="padding: 0px; margin: 0px;">PFT:<br style="padding: 0px; margin: 0px;">PVT:<br style="padding: 0px; margin: 0px;">id....................0002<br style="padding: 0px; margin: 0px;">raddr.....0000000000686000 eaddr.....F200800030000000<br style="padding: 0px; margin: 0px;">size..............00040000 align.............00001000<br style="padding: 0px; margin: 0px;">valid..1 ros....0 fixlmb.1 seg....0 wimg...2<br style="padding: 0px; margin: 0px;">Dump analysis on CHRP_SMP_PCI POWER_PC POWER_5 machine with 8 available CPU(s) <br style="padding: 0px; margin: 0px;">(64-bit registers)<br style="padding: 0px; margin: 0px;">Processing symbol table...<br style="padding: 0px; margin: 0px;">.......................done<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;"><strong style="padding: 0px; margin: 0px;">分析命令示例</strong></p><p style="padding: 0px 0px 15px; margin: 0px;">status 查看各个 CPU 在 dump 时正在运行的进程，如：</p><table style="padding: 0px; margin: 0px auto; font-size: 12px;" border="0" width="50%" cellpadding="0" cellspacing="0"><tbody style="padding: 0px; margin: 0px;"><tr style="padding: 0px; margin: 0px;"><td style="padding: 0px; margin: 0px;"><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; overflow: auto; width: 356px;">0)&gt; status<br style="padding: 0px; margin: 0px;">CPU TID TSLOT PID PSLOT PROC_NAME<br style="padding: 0px; margin: 0px;"> 0 2580F5 600 14C0F6 332 cron<br style="padding: 0px; margin: 0px;"> 1 12025 18 D01A 13 wait<br style="padding: 0px; margin: 0px;"> 2 1020BB 258 1580C6 344 expr<br style="padding: 0px; margin: 0px;"> 3 1502B 21 F01E 15 wait<br style="padding: 0px; margin: 0px;"></pre></td></tr></tbody></table><p style="padding: 0px 0px 15px; margin: 0px;"><br style="padding: 0px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">cpu &lt;id&gt; 命令切换当前 CPU，默认的当前 CPU 为 cpu0：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; cpu 1</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(1)&gt;</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">打印系统的基本状态和相关信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; stat</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">打印系统 dump 时内核栈的情况：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; f</p><p style="padding: 0px 0px 15px; margin: 0px;">lke 用来列出内核代码对应的相关系统文件信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; lke 003DE9CC</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">显示系统 dump 时最后所在的指令：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; dr iar</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">显示虚拟存储管理的日志信息；其中 Exception value 若为 0000001C 则表示 pagingspace 耗尽：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; vmlog</p><p style="padding: 0px 0px 15px; margin: 0px;">显示进程表的信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; proc</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">显示线程表的信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; th</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">显示系统的 errpt 信息：</p><p style="padding: 0px 0px 15px; margin: 0px;"></p><p style="padding: 0px 0px 15px; margin: 0px;">(0)&gt; errpt</p><pre style="padding: 0px; margin-top: 0px; background-color: rgb(247, 247, 247); font-family: 'Courier New',monospace; font-size: 12px; overflow: auto; width: 712px;">ERRORS NOT READ BY ERRDEMON (ORDERED CHRONOLOGICALLY):<br style="padding: 0px; margin: 0px;"><br style="padding: 0px; margin: 0px;">Error Record:<br style="padding: 0px; margin: 0px;">erec_flags .............. 1<br style="padding: 0px; margin: 0px;">erec_len ................ 54<br style="padding: 0px; margin: 0px;">erec_timestamp .......... 46DCDD9D<br style="padding: 0px; margin: 0px;">erec_rec_len ............ 34<br style="padding: 0px; margin: 0px;">erec_dupcount ........... 0<br style="padding: 0px; margin: 0px;">erec_duptime1 ........... 0<br style="padding: 0px; margin: 0px;">erec_duptime2 ........... 0<br style="padding: 0px; margin: 0px;">erec_rec.error_id ....... DD11B4AF<br style="padding: 0px; margin: 0px;">erec_rec.resource_name .. SYSPROC<br style="padding: 0px; margin: 0px;">00007FFF FFFFD000 00000000 003DE9CC .............=..<br style="padding: 0px; margin: 0px;">00000000 00020000 80000000 000290B2 ................</pre>
